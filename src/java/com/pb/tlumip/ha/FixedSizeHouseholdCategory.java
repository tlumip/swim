/*
 * Copyright  2005 PB Consult Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
/* Generated by Together */

package com.pb.tlumip.ha;

import java.util.Collection;
import java.util.Iterator;
import java.util.Vector;


public class FixedSizeHouseholdCategory extends HouseholdCategory {

	short minAutos = 0;
	short maxAutos = 3;
    short minYearsSinceMove;
    short maxYearsSinceMove;


    public static class PersonDescriptor {
        int minAge;
        int maxAge;
        char gender; //'M', 'F' or any other character
        double fullTimeEmployedProbability;
        double partTimeEmployedProbability;
        double schoolProbability;
        int minEducation;
        int maxEducation;

        private boolean matches(Person p) {
            if (p.age >= minAge && p.age <= maxAge) {
                if ((gender == 'M' || gender == 'm') && p.female) return false;
                if ((gender == 'F' || gender == 'f') && !p.female) return false;
                return true;
            }
            return false;
        }
        	/**
		 * Method employStatus.
		 * @return short
		 */
		private short employStatus() {
			double selector = Math.random();
			if (selector < fullTimeEmployedProbability) return 2;
			if (selector < fullTimeEmployedProbability + partTimeEmployedProbability) return 1;
			return 0;
		}
	
		/**
		 * Method schoolStatus.
		 * @return short
		 */
		private short schoolStatus() {
			if (Math.random() < schoolProbability) return 2;
			return 1;
		}

		/**
		 * Method yearsSchool.
		 * @return short
		 */
		private short yearsSchool() {
			return (short) (minEducation + Math.random()*(maxEducation-minEducation));
		}




    }


    private Vector peopleDescriptors = new Vector();

    public void addPerson(int minAge, int maxAge, char gender) {
        PersonDescriptor pd = new PersonDescriptor();
        pd.minAge = minAge;
        pd.maxAge = maxAge;
        pd.gender = gender;
        peopleDescriptors.add(pd);
    }
    
    public void addPerson(PersonDescriptor pd) {
    	peopleDescriptors.add(pd);
    }

    public boolean householdFits(Household h) {
        if (h.getPeople().size() != peopleDescriptors.size()) {
            return false;
        }
        Person[] pa = new Person[h.getPeople().size()];
        pa = (Person[]) h.getPeople().toArray(pa);
        boolean[] foundem = new boolean[peopleDescriptors.size()];
        for (int pdi = 0; pdi < foundem.length; pdi++) foundem[pdi] = false;
        for (int p = 0; p < pa.length; p++) {
            int pdi = 0;
            boolean matched = false;
            while (pdi < foundem.length && matched == false) {
                if (foundem[pdi] != true) {
                    PersonDescriptor personType = (PersonDescriptor)peopleDescriptors.elementAt(pdi);
                    if (personType.matches(pa[p])) {
                        foundem[pdi] = true;
                        matched = true;
                    } else
                        pdi++;
                } else
                    pdi++;
            }
            if (matched == false) {
                return false;
            }
        }
        return true;
    }

    public Household createANewHousehold() {
      Iterator i = peopleDescriptors.iterator();
      Household h = new Household();
      while (i.hasNext()) {
        Person p = new Person();
        PersonDescriptor pd = (PersonDescriptor) i.next();
        p.age = pd.minAge + (int) (Math.random()*(pd.maxAge-pd.minAge));
        if (Math.random()>0.5) p.female = true; else p.female = false;
        if (pd.gender == 'F' || pd.gender == 'f') p.female = true;
        if (pd.gender == 'M' || pd.gender == 'm') p.female = false;
        p.employStatus = pd.employStatus();
        p.schoolStatus = pd.schoolStatus();
        p.yearsSchool = pd.yearsSchool();
        if (p.employStatus >0) p.sampleInitialOccupation();
        p.samplePreferences();
        p.addToHousehold(h);
      }
      h.setAutos((short) (minAutos + Math.random()*(maxAutos-minAutos)));
      h.setYearsSinceMove((short) (minYearsSinceMove + Math.random()*(maxYearsSinceMove-minYearsSinceMove)));
   //   h.setConsumptionFunction(generateAConsumptionFunction());
   //   h.setProductionFunction(generateAProductionFunction());
      return h;
    }
    

    public Household createANewHousehold(Collection c) {
      Iterator i = peopleDescriptors.iterator();
      Household h = new Household();
      while (i.hasNext()) {
        PersonDescriptor pd = (PersonDescriptor) i.next();
        Iterator peopleToChooseFrom = c.iterator();
        boolean matched = false;
        while (peopleToChooseFrom.hasNext()&&matched==false) {
          Person p = (Person) peopleToChooseFrom.next();
          if (pd.matches(p)) {
            p.addToHousehold(h);
            c.remove(p);
            matched = true;
            break;
          }
        }
        if (matched == false) {
          // give up, put everyone back
          h.dissolveInto(c);
          return null;
        }
      }
      h.setAutos((short) (minAutos + Math.random()*(maxAutos-minAutos)));
      h.setYearsSinceMove((short) (minYearsSinceMove + Math.random()*(maxYearsSinceMove-minYearsSinceMove)));
   //      h.setConsumptionFunction(generateAConsumptionFunction());
   //   h.setProductionFunction(generateAProductionFunction());
      return h;
   }

//   abstract public ConsumptionFunction generateAConsumptionFunction();
//   abstract public ProductionFunction generateAProductionFunction();

}

